<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Schiffeversenken Modern Pixel</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --cyan:#9fd7ff;
      --blue:#4b80b8;
      --deep:#071325;
      --panel:#0b1627e6;
      --line:#415b7a;
      --steel:#8da3bd;
    }
    body {
      font-family: Inter, Segoe UI, Arial, sans-serif;
      background:
        radial-gradient(circle at 20% 12%, #1b2c45 0, transparent 34%),
        radial-gradient(circle at 78% 10%, #1b2638 0, transparent 32%),
        linear-gradient(180deg, #03070f 0%, #071325 60%, #050911 100%);
      color: #e9f3ff;
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 16px;
      overflow-x: hidden;
    }
    .bg-grid {
      position: fixed; inset: 0; pointer-events: none; opacity: .16;
      background-image:
        linear-gradient(rgba(120,155,188,.22) 1px, transparent 1px),
        linear-gradient(90deg, rgba(120,155,188,.18) 1px, transparent 1px);
      background-size: 42px 42px;
      mask-image: radial-gradient(circle at 50% 45%, #000 35%, transparent 90%);
    }
    .vignette {
      position: fixed; inset: 0; pointer-events: none;
      background: radial-gradient(circle at center, transparent 35%, rgba(0,0,0,.6) 100%);
    }
    .game {
      position: relative;
      width: min(1250px, 100%);
      background: linear-gradient(180deg, rgba(10,20,34,.96), rgba(7,15,27,.96));
      border: 1px solid #4f647f;
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,.45), 0 0 35px rgba(80,170,255,.15);
      backdrop-filter: blur(8px);
    }
    h1 {
      text-align: center;
      margin-bottom: 10px;
      color: #c4d6ea;
      letter-spacing: 1.2px;
      text-shadow: 0 0 10px rgba(85,120,160,.3);
      text-transform: uppercase;
      font-size: 1.35rem;
    }
    .setup, .status { margin-bottom: 14px; text-align: center; }
    .status {
      border: 1px solid #2f5d95;
      background: rgba(10,30,56,.6);
      border-radius: 10px;
      padding: 10px;
      box-shadow: inset 0 0 10px rgba(62,131,204,.15);
    }
    .hud {
      display:grid;
      grid-template-columns: repeat(4,minmax(110px,1fr));
      gap:8px;
      margin-bottom:10px;
    }
    .hud .box{
      border:1px solid #3f5a79;
      background: rgba(9,22,38,.75);
      border-radius:8px;
      padding:8px;
      text-align:center;
      font-size:12px;
      color:#bdd0e6;
    }
    .hud .box b{display:block; font-size:14px; color:#e8f2ff; margin-top:2px;}
    .row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin: 10px 0; }
    button {
      background: linear-gradient(135deg, #2a3c55, #334862 55%, #415775);
      color: #e9f2fb;
      border: 1px solid rgba(168,188,212,.55);
      border-radius: 11px;
      padding: 10px 14px;
      font-weight: 800;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,.35);
      transition: transform .16s ease, box-shadow .16s ease, filter .16s ease;
    }
    button:hover {
      transform: translateY(-1px) scale(1.02);
      box-shadow: 0 10px 24px rgba(52,78,110,.45);
      filter: saturate(1.02);
    }
    button:disabled { opacity: .45; cursor: not-allowed; transform:none; }
    .boards { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      box-shadow: inset 0 0 16px rgba(70,92,122,.2);
      position: relative;
    }
    .panel::before {
      content: '';
      position: absolute;
      left: 10px; right: 10px; top: 8px;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(160,180,206,.45), transparent);
    }
    .panel h3 { text-align: center; margin-bottom: 8px; color: #bfd1e6; letter-spacing: .8px; text-transform: uppercase; font-size: .9rem; }
    .board {
      display: grid;
      grid-template-columns: repeat(11, 34px);
      grid-template-rows: repeat(11, 34px);
      gap: 2px;
      justify-content: center;
      user-select: none;
      touch-action: manipulation;
    }
    .cell {
      position: relative;
      border: 1px solid #3568a0;
      background:
        linear-gradient(180deg, #0e4f8f, #0a3a6b),
        repeating-linear-gradient(45deg, rgba(255,255,255,.04) 0 2px, transparent 2px 6px);
      display: grid;
      place-items: center;
      color: #cbe9ff;
      overflow: hidden;
    }
    .header { background: linear-gradient(180deg, #1a4a86, #12345f); font-size: 12px; font-weight: 800; }
    .clickable:hover { filter: brightness(1.22) saturate(1.1); cursor: crosshair; }

    .ship-cell {
      background-size: cover;
      background-position: center;
      image-rendering: pixelated;
    }
    .ship-hidden { background-image: none !important; }

    .hit { background: linear-gradient(180deg,#8e1e1e,#5d1010) !important; box-shadow: inset 0 0 10px rgba(255,128,64,.4); }
    .miss { background: linear-gradient(180deg,#1779a5,#115679) !important; }
    .sunk {
      outline: 2px solid #ff8f36;
      box-shadow: 0 0 12px rgba(255,143,54,.45), inset 0 0 14px rgba(0,0,0,.45);
      filter: saturate(.35) brightness(.8);
    }

    .anim {
      position: absolute; width: 28px; height: 28px; pointer-events: none; image-rendering: pixelated;
      animation: pop .42s ease-out forwards;
    }
    .anim.hitfx { background: radial-gradient(circle, #fff 0 14%, #ffe17a 15% 35%, #ff7137 36% 62%, #8f1d00 63% 100%); }
    .anim.missfx { background: radial-gradient(circle, #d3f2ff 0 18%, #8ee7ff 19% 42%, #1fa5cf 43% 100%); }
    @keyframes pop {
      0% { transform: scale(.2); opacity: 0; }
      45% { transform: scale(1.35); opacity: 1; }
      100% { transform: scale(1); opacity: 0; }
    }

    .ship-list { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; margin: 8px 0; }
    .ship-item {
      padding: 8px 10px;
      border: 1px solid #4f80bc;
      border-radius: 8px;
      background: linear-gradient(180deg,#123055,#0f2745);
      cursor: pointer;
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .ship-item:hover { transform: translateY(-1px); box-shadow: 0 6px 12px rgba(0,0,0,.25); }
    .ship-item.sel { outline: 2px solid #89d5ff; box-shadow: 0 0 10px rgba(137,213,255,.35); }
    .ship-item.done { background: linear-gradient(180deg,#17875f,#146c4d); border-color: #2fbf8a; }

    .small { font-size: 13px; opacity: .95; }
    .popup {
      position: fixed;
      left: 50%;
      top: 24px;
      transform: translateX(-50%) translateY(-20px);
      background: linear-gradient(135deg, rgba(20,40,72,.95), rgba(16,84,128,.95));
      border: 1px solid #77d9ff;
      border-radius: 12px;
      padding: 12px 18px;
      font-weight: 800;
      letter-spacing: .3px;
      box-shadow: 0 12px 30px rgba(0,0,0,.4);
      opacity: 0;
      pointer-events: none;
      z-index: 9999;
      transition: all .25s ease;
      color: #e9f8ff;
    }
    .popup.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    .popup.hit { border-color:#ffd96a; }
    .popup.sunk { border-color:#ff9e57; }
    .popup.win { border-color:#6dffad; }
    .popup.lose { border-color:#ff7f8c; }
    .rules {
      margin: 12px auto 0;
      max-width: 880px;
      text-align: left;
      background: rgba(9, 27, 49, .65);
      border: 1px solid #335f95;
      border-radius: 10px;
      padding: 12px 14px;
      line-height: 1.45;
      font-size: 13px;
    }
    .rules b { color: #9fdcff; }
    .hide { display: none !important; }

    @media (max-width: 980px) {
      .boards { grid-template-columns: 1fr; }
      .board { grid-template-columns: repeat(11, 30px); grid-template-rows: repeat(11, 30px); }
    }
    @media (max-width: 640px) {
      body { padding: 8px; }
      .game { padding: 10px; border-radius: 12px; }
      h1 { font-size: 1.25rem; margin-bottom: 8px; }
      .panel { padding: 6px; }
      .board { grid-template-columns: repeat(11, 25px); grid-template-rows: repeat(11, 25px); gap: 1px; }
      .cell { font-size: 11px; }
      .row { gap: 6px; margin: 6px 0; }
      button { padding: 8px 10px; font-size: 13px; border-radius: 8px; }
      .rules { font-size: 12px; padding: 8px 10px; }
      .popup { top: 8px; width: calc(100% - 16px); left: 8px; transform: translateY(-20px); padding: 10px 12px; }
      .popup.show { transform: translateY(0); }
    }
  </style>
</head>
<body>
  <div class="bg-grid"></div>
  <div class="vignette"></div>
  <div id="popup" class="popup"></div>
  <div class="game">
    <h1>‚öì Einsatzleitung Flotte ‚Äî Schiffeversenken</h1>
    <div class="small" style="text-align:center; margin-top:-6px; margin-bottom:10px; opacity:.85; letter-spacing:.4px; color:#b6c9dd;">TACTICAL NAVAL HUD ‚Ä¢ Phase 1 (Look & Interface)</div>

    <div id="setup" class="setup">
      <div class="row">
        <button onclick="setMode('ai')">Solo vs KI</button>
        <button onclick="setMode('pvp')">1 vs 1 (Hotseat)</button>
      </div>
      <div class="row" id="difficultyRow">
        <button onclick="startNew('leicht')">Leicht</button>
        <button onclick="startNew('mittel')">Mittel</button>
        <button onclick="startNew('schwer')">Schwer</button>
      </div>
      <div class="small">Pixel-Sprites + Animationen + Soundeffekte aktiv. R = Schiff drehen.</div>
      <div class="row" style="margin-top:8px;">
        <button onclick="setFxLevel('low')">FX niedrig</button>
        <button onclick="setFxLevel('normal')">FX normal</button>
        <button onclick="setFxLevel('high')">FX hoch</button>
        <button onclick="setSoundStyle('arcade')">Sound: Arcade v2</button>
        <button onclick="setSoundStyle('naval')">Sound: Naval v2</button>
      </div>
      <div class="row hide" id="postGameRow">
        <button onclick="playAgain()">üîÅ Nochmal spielen</button>
        <button onclick="goToStart()">‚Ü©Ô∏è Zum Startbildschirm</button>
      </div>
      <div class="rules">
        <b>Spielregeln:</b><br>
        ‚Ä¢ 10√ó10 Feld, 5 Schiffe pro Seite (5/4/3/3/2).<br>
        ‚Ä¢ Schiffe nur horizontal oder vertikal.<br>
        ‚Ä¢ Schiffe d√ºrfen sich <b>nicht ber√ºhren</b> (auch nicht diagonal).<br>
        ‚Ä¢ Pro Zug ein Schuss. Ergebnis: Wasser / Treffer / Versenkt.<br>
        ‚Ä¢ Wer alle gegnerischen Schiffe versenkt, gewinnt.<br>
        ‚Ä¢ Diese Regeln gelten f√ºr Spieler <b>und</b> KI gleicherma√üen.
      </div>
    </div>

    <div id="placement" class="hide">
      <div class="status" id="placementTitle"></div>
      <div class="ship-list" id="shipList"></div>
      <div class="row">
        <button onclick="toggleOrientation()">Drehen ‚Üª</button>
        <button onclick="randomPlacement()">Zuf√§llig platzieren</button>
        <button onclick="finishPlacement()" id="btnPlacementDone" disabled>Platzierung fertig</button>
      </div>
      <div class="small" style="text-align:center">W√§hle Schiff ‚Üí tippe Feld. Taste R oder Button ‚ÄûDrehen‚Äú wechselt Horizontal/Vertikal.</div>
    </div>

    <div id="status" class="status hide"></div>
    <div id="hud" class="hud hide">
      <div class="box">Rolle<b id="hudRole">-</b></div>
      <div class="box">Zug<b id="hudTurn">-</b></div>
      <div class="box">Sch√ºsse<b id="hudShots">0</b></div>
      <div class="box">Trefferquote<b id="hudAcc">0%</b></div>
    </div>

    <div class="boards hide" id="boards">
      <div class="panel">
        <h3 id="titleLeft">Spieler 1</h3>
        <div class="board" id="boardLeft"></div>
      </div>
      <div class="panel">
        <h3 id="titleRight">Gegner</h3>
        <div class="board" id="boardRight"></div>
      </div>
    </div>
  </div>

  
  <script>
    const N = 10;
    const SHIPS = [
      { id:'carrier', name:'Flugzeugtr√§ger', size:5, hue:200 },
      { id:'battleship', name:'Schlachtschiff', size:4, hue:170 },
      { id:'cruiser', name:'Kreuzer', size:3, hue:145 },
      { id:'submarine', name:'U-Boot', size:3, hue:120 },
      { id:'destroyer', name:'Zerst√∂rer', size:2, hue:95 }
    ];

    let mode = 'ai';
    let difficulty = 'mittel';
    let phase = 'setup'; // setup, placement, battle, over
    let placementPlayer = 1;
    let currentPlayer = 1; // turn owner in battle
    let selShip = null;
    let horizontal = true;
    let aiTargets = [];
    let aiFocusShipId = null;
    let aiHitCells = [];
    let lastTapAt = 0;

    const state = {
      p1: makePlayer('Spieler 1'),
      p2: makePlayer('Spieler 2'),
      ai: makePlayer('KI')
    };

    const sprites = {};
    let actx;
    let fxLevel = 'normal';
    let soundStyle = 'arcade';
    
    function makePlayer(name){
      return { name, board:emptyBoard(), ships:{}, shots:new Set(), hits:0, totalShots:0 };
    }
    function emptyBoard(){ return Array.from({length:N},()=>Array.from({length:N},()=>({ ship:null, hit:false, miss:false }))); }
    const key=(r,c)=>`${r},${c}`;

    function setMode(m){
      mode = m;
      document.getElementById('difficultyRow').classList.toggle('hide', m==='pvp');
      setStatus(m==='pvp' ? 'Modus: 1 vs 1 Hotseat gew√§hlt.' : 'Modus: Solo vs KI gew√§hlt.');
    }

    function setFxLevel(level='normal'){
      fxLevel = level;
      showPopup(`FX-Level: ${level.toUpperCase()}`, 'hit', 900);
    }

    function setSoundStyle(style='arcade'){
      soundStyle = style;
      showPopup(`Sound: ${style==='naval' ? 'Naval' : 'Arcade'}`, 'hit', 900);
      
    }

    function ensureAudio(){
      if(!actx) actx = new (window.AudioContext||window.webkitAudioContext)();
      if(actx.state === 'suspended') actx.resume();
    }

    function startNew(diff='mittel'){
      difficulty = diff;
      phase = 'placement';
      document.getElementById('postGameRow')?.classList.add('hide');
      aiTargets = [];
      aiFocusShipId = null;
      aiHitCells = [];
      placementPlayer = 1;
      currentPlayer = 1;
      state.p1 = makePlayer('Spieler 1');
      state.p2 = makePlayer('Spieler 2');
      state.ai = makePlayer('KI');
      selShip = null;
      horizontal = true;

      document.getElementById('setup').classList.add('hide');
      document.getElementById('placement').classList.remove('hide');
      document.getElementById('boards').classList.remove('hide');
      document.getElementById('status').classList.remove('hide');
      document.getElementById('hud').classList.remove('hide');

      renderShipList();
      renderBoards();
      setPlacementTitle();
      setStatus('Platziere deine Flotte.');
      updateHud();
    }

    function setPlacementTitle(){
      const who = placementPlayer===1 ? 'Spieler 1' : (mode==='pvp' ? 'Spieler 2' : 'du');
      document.getElementById('placementTitle').textContent = `Platzierung: ${who} (${horizontal?'Horizontal':'Vertikal'})`;
    }

    function toggleOrientation(){
      horizontal = !horizontal;
      setPlacementTitle();
      playSfx('turn');
    }

    function renderShipList(){
      const host = document.getElementById('shipList');
      const me = getPlacementTarget();
      host.innerHTML='';
      for(const s of SHIPS){
        const d=document.createElement('div');
        d.className='ship-item';
        d.textContent=`${s.name} (${s.size})`;
        if(me.ships[s.id]) d.classList.add('done');
        if(selShip && selShip.id===s.id) d.classList.add('sel');
        d.onclick=()=>{ if(!me.ships[s.id]) { selShip=s; renderShipList(); }};
        host.appendChild(d);
      }
      document.getElementById('btnPlacementDone').disabled = Object.keys(me.ships).length !== SHIPS.length;
    }

    function getPlacementTarget(){
      if(placementPlayer===1) return state.p1;
      return mode==='pvp' ? state.p2 : state.p1;
    }

    function createBoard(el, ownerLabel){
      el.innerHTML='';
      el.appendChild(cell('','header'));
      for(let c=0;c<N;c++) el.appendChild(cell(String.fromCharCode(65+c),'header'));
      for(let r=0;r<N;r++){
        el.appendChild(cell(String(r+1),'header'));
        for(let c=0;c<N;c++){
          const d = cell('');
          d.dataset.r=r; d.dataset.c=c;
          d.classList.add('clickable');
          d.onclick=()=>onBoardCellClick(ownerLabel,r,c,d);
          el.appendChild(d);
        }
      }
    }

    function cell(t, cl=''){ const d=document.createElement('div'); d.className='cell'+(cl?(' '+cl):''); d.textContent=t; return d; }

    function renderBoards(){
      createBoard(document.getElementById('boardLeft'),'left');
      createBoard(document.getElementById('boardRight'),'right');
      document.getElementById('titleLeft').textContent = mode==='pvp' ? 'Spieler 1 ¬∑ Flottensektor' : 'Eigene Flotte ¬∑ Sektor';
      document.getElementById('titleRight').textContent = mode==='pvp' ? 'Spieler 2 ¬∑ Flottensektor' : 'Zielradar ¬∑ Gegnersektor';
      refreshBoardVisuals();
    }

    function refreshBoardVisuals(){
      const left = state.p1.board;
      const right = mode==='pvp' ? state.p2.board : state.ai.board;
      paintGrid('boardLeft', left, true, mode==='pvp' && phase==='battle' && currentPlayer===2);
      paintGrid('boardRight', right, mode==='pvp' || phase!=='battle', mode==='pvp' && phase==='battle' && currentPlayer===1);
    }

    function paintGrid(boardId, board, showShips, hideByTurn=false){
      const root = document.getElementById(boardId);
      root.querySelectorAll('.cell:not(.header)').forEach(c=>{
        const r=+c.dataset.r, col=+c.dataset.c;
        const v = board[r][col];
        c.classList.remove('ship-cell','ship-hidden','hit','miss','sunk');
        c.textContent=''; c.style.backgroundImage='';

        if(v.ship && showShips){
          c.classList.add('ship-cell');
          c.style.backgroundImage = `url(${sprites[v.ship.id]})`;
          if (board[r][col].ship && (board[r][col].ship.id in (mode==='pvp' && board===state.p2.board ? state.p2.ships : (board===state.p1.board ? state.p1.ships : state.ai.ships)))) {
            const shipsRef = (mode==='pvp' && board===state.p2.board) ? state.p2.ships : (board===state.p1.board ? state.p1.ships : state.ai.ships);
            if (shipsRef[v.ship.id]?.sunk) c.classList.add('sunk');
          }
        }
        if(v.hit){ c.classList.add('hit'); c.textContent='‚úñ'; }
        if(v.miss){ c.classList.add('miss'); c.textContent='‚Ä¢'; }
        if(v.ship && (board===state.p1.board ? state.p1.ships[v.ship.id]?.sunk : (board===state.ai.board ? state.ai.ships[v.ship.id]?.sunk : state.p2.ships[v.ship.id]?.sunk))){
          c.classList.add('sunk');
          if(v.hit) c.textContent='‚ò†';
        }
      });
      if(hideByTurn){
        root.style.filter='brightness(.7)';
      } else root.style.filter='none';
    }

    function onBoardCellClick(side,r,c,cellEl){
      const now = Date.now();
      if (now - lastTapAt < 220) return; // double-tap Schutz
      lastTapAt = now;

      if (cellEl && cellEl.dataset.tapLock === '1') return;
      if (cellEl) {
        cellEl.dataset.tapLock = '1';
        setTimeout(() => { if(cellEl) cellEl.dataset.tapLock = '0'; }, 260);
      }

      if(phase==='placement') return placementClick(side,r,c);
      if(phase==='battle') return battleClick(side,r,c,cellEl);
    }

    function placementClick(side,r,c){
      const target = placementPlayer===1 ? state.p1 : (mode==='pvp' ? state.p2 : state.p1);
      const validSide = (placementPlayer===1 && side==='left') || (placementPlayer===2 && side==='right') || (mode==='ai' && side==='left');
      if(!validSide || !selShip) return;
      if(!canPlace(target.board, r,c, selShip.size, horizontal)) return;
      const pos=[];
      for(let i=0;i<selShip.size;i++){
        const rr = horizontal ? r : r+i;
        const cc = horizontal ? c+i : c;
        target.board[rr][cc].ship = selShip;
        pos.push({r:rr,c:cc});
      }
      target.ships[selShip.id]={ ...selShip, cells:pos, hits:0, sunk:false };
      playSfx('place');
      selShip=null;
      renderShipList();
      refreshBoardVisuals();
    }

    function canPlace(board,r,c,size,h){
      const planned=[];
      for(let i=0;i<size;i++){
        const rr = h ? r : r+i;
        const cc = h ? c+i : c;
        if(rr<0||cc<0||rr>=N||cc>=N) return false;
        if(board[rr][cc].ship) return false;
        planned.push([rr,cc]);
      }
      // Regel: Schiffe d√ºrfen sich nicht ber√ºhren (auch nicht diagonal)
      for (const [rr,cc] of planned) {
        for (let dr=-1; dr<=1; dr++) {
          for (let dc=-1; dc<=1; dc++) {
            const nr = rr + dr, nc = cc + dc;
            if (nr<0 || nc<0 || nr>=N || nc>=N) continue;
            if (board[nr][nc].ship) return false;
          }
        }
      }
      return true;
    }

    function randomPlacement(){
      const t = placementPlayer===1 ? state.p1 : (mode==='pvp' ? state.p2 : state.p1);
      t.board = emptyBoard(); t.ships={};
      for(const s of SHIPS){
        let ok=false;
        while(!ok){
          const r=(Math.random()*N)|0, c=(Math.random()*N)|0, h=Math.random()<.5;
          if(canPlace(t.board,r,c,s.size,h)){
            const pos=[];
            for(let i=0;i<s.size;i++){
              const rr=h?r:r+i, cc=h?c+i:c;
              t.board[rr][cc].ship=s; pos.push({r:rr,c:cc});
            }
            t.ships[s.id]={...s,cells:pos,hits:0,sunk:false}; ok=true;
          }
        }
      }
      playSfx('place');
      renderShipList();
      refreshBoardVisuals();
    }

    function finishPlacement(){
      const t = getPlacementTarget();
      if(Object.keys(t.ships).length !== SHIPS.length) return;
      if(mode==='ai'){
        autoPlaceAI();
        beginBattle();
        return;
      }
      if(placementPlayer===1){
        placementPlayer=2;
        selShip=null;
        setPlacementTitle();
        renderShipList();
        setStatus('Spieler 2 √ºbernimmt und platziert jetzt.');
        playSfx('turn');
      } else {
        beginBattle();
      }
    }

    function autoPlaceAI(){
      const t = state.ai;
      t.board = emptyBoard(); t.ships={};
      for(const s of SHIPS){
        let ok=false;
        while(!ok){
          const r=(Math.random()*N)|0, c=(Math.random()*N)|0, h=Math.random()<.5;
          if(canPlace(t.board,r,c,s.size,h)){
            const pos=[];
            for(let i=0;i<s.size;i++){
              const rr=h?r:r+i, cc=h?c+i:c;
              t.board[rr][cc].ship=s; pos.push({r:rr,c:cc});
            }
            t.ships[s.id]={...s,cells:pos,hits:0,sunk:false}; ok=true;
          }
        }
      }
    }

    function beginBattle(){
      phase='battle';
      document.getElementById('placement').classList.add('hide');
      currentPlayer=1;
      setStatus(mode==='ai' ? 'Dein Zug auf dem rechten Feld.' : 'Spieler 1 beginnt auf dem rechten Feld.');
      playSfx('turn');
      refreshBoardVisuals();
      updateHud();
    }

    function battleClick(side,r,c,el){
      const target = (currentPlayer===1)
        ? (mode==='ai' ? state.ai : state.p2)
        : state.p1;
      const attackSide = currentPlayer===1 ? 'right' : 'left';
      if(side!==attackSide) return;
      const shooter = currentPlayer===1 ? state.p1 : (mode==='ai' ? state.ai : state.p2);
      if(target.shots.has(key(r,c))) return;

      target.shots.add(key(r,c));
      shooter.totalShots++;
      const cell = target.board[r][c];
      const enemyActionOnMe = (mode==='ai' && currentPlayer===2);
      if(cell.ship){
        cell.hit=true; shooter.hits++;
        animate(el,'hitfx');
        playSfx('hit');
        const sh = target.ships[cell.ship.id];
        sh.hits++;
        if(sh.hits>=sh.size){
          sh.sunk=true;
          for(const p of sh.cells){ target.board[p.r][p.c].hit=true; }
          playSfx('sunk');
          const who = currentPlayer===1 ? 'Spieler 1' : (mode==='ai' ? 'KI' : 'Spieler 2');
          if (!enemyActionOnMe) setStatus(`${who} versenkt: ${sh.name}`);
          if (!enemyActionOnMe) showPopup(`üí• Versenkt! ${sh.name}`, 'sunk');
        } else {
          if (!enemyActionOnMe) setStatus('Treffer!');
          if (!enemyActionOnMe) showPopup('üéØ Treffer!', 'hit');
        }
      } else {
        cell.miss=true;
        animate(el,'missfx');
        playSfx('miss');
        if (!enemyActionOnMe) setStatus('Daneben.');
      }

      // Regel: Bei Treffer darf derselbe Spieler nochmal schie√üen; bei Fehlschuss wechselt der Zug.
      if(!cell.ship){
        currentPlayer = currentPlayer===1 ? 2 : 1;
        playSfx('turn');
      }

      refreshBoardVisuals();
      checkGameOver();
      updateHud();
      if (phase==='battle' && mode==='ai' && currentPlayer===1) {
        setStatus('Dein Zug auf dem rechten Feld.');
      }
      if(phase==='battle' && mode==='ai' && currentPlayer===2){
        setTimeout(aiMove, 500);
        return;
      }
    }

    function pushAiTarget(nr,nc){
      if(nr<0||nc<0||nr>=N||nc>=N) return;
      const k = key(nr,nc);
      if(state.p1.shots.has(k)) return;
      if(aiTargets.some(t => t[0]===nr && t[1]===nc)) return;
      aiTargets.push([nr,nc]);
    }

    function enqueueAiNeighbors(r,c){
      pushAiTarget(r-1,c); pushAiTarget(r+1,c); pushAiTarget(r,c-1); pushAiTarget(r,c+1);
    }

    function enqueueAiLineTargets(){
      if(aiHitCells.length < 2) return;
      const rows = aiHitCells.map(h=>h[0]);
      const cols = aiHitCells.map(h=>h[1]);
      const sameRow = rows.every(v => v===rows[0]);
      const sameCol = cols.every(v => v===cols[0]);

      aiTargets = [];
      if(sameRow){
        const r = rows[0], minC = Math.min(...cols), maxC = Math.max(...cols);
        pushAiTarget(r, minC-1);
        pushAiTarget(r, maxC+1);
      } else if(sameCol){
        const c = cols[0], minR = Math.min(...rows), maxR = Math.max(...rows);
        pushAiTarget(minR-1, c);
        pushAiTarget(maxR+1, c);
      }
    }

    function aiMove(){
      if(phase!=='battle') return;
      let r,c;

      while(aiTargets.length){
        const t = aiTargets.shift();
        if(!state.p1.shots.has(key(t[0],t[1]))){
          [r,c] = t;
          break;
        }
      }

      if(r===undefined){
        const list=[];
        for(let i=0;i<N;i++) for(let j=0;j<N;j++) if(!state.p1.shots.has(key(i,j))) list.push([i,j]);
        if(difficulty==='schwer') list.sort((a,b)=>((b[0]+b[1])%2)-((a[0]+a[1])%2));
        [r,c] = list[(Math.random()*list.length)|0];
      }

      const targetCell = state.p1.board[r][c];
      const willHit = !!targetCell.ship;
      const hitShipId = willHit ? targetCell.ship.id : null;
      const willSink = willHit ? (state.p1.ships[hitShipId].hits + 1 >= state.p1.ships[hitShipId].size) : false;

      const fakeEl = document.querySelector(`#boardLeft .cell[data-r='${r}'][data-c='${c}']`);
      battleClick('left',r,c,fakeEl);

      if(!willHit) return;

      if(willSink){
        aiFocusShipId = null;
        aiHitCells = [];
        aiTargets = [];
        return;
      }

      if(!aiFocusShipId || aiFocusShipId !== hitShipId){
        aiFocusShipId = hitShipId;
        aiHitCells = [];
        aiTargets = [];
      }

      aiHitCells.push([r,c]);
      if(aiHitCells.length >= 2) enqueueAiLineTargets();
      else enqueueAiNeighbors(r,c);
    }

    function checkGameOver(){
      const aAll = Object.values((mode==='ai'?state.ai:state.p2).ships).every(s=>s.sunk);
      const p1All = Object.values(state.p1.ships).every(s=>s.sunk);
      if(aAll || p1All){
        phase='over';
        const win = aAll;
        setStatus(win ? 'üéâ Sieg!' : 'üí• Niederlage');
        document.getElementById('postGameRow')?.classList.remove('hide');
        showPopup(win ? 'üèÜ Sieg! Alle gegnerischen Schiffe versenkt.' : '‚ò†Ô∏è Niederlage! Deine Flotte wurde versenkt.', win ? 'win' : 'lose', 2600);
        playSfx(win?'win':'lose');
      }
    }

    function playAgain(){
      document.getElementById('postGameRow')?.classList.add('hide');
      if(mode==='ai') startNew(difficulty);
      else {
        // Im Hotseat direkt neu in die Platzierungsphase
        startNew('mittel');
      }
    }

    function goToStart(){
      phase = 'setup';
      currentPlayer = 1;
      placementPlayer = 1;
      selShip = null;
      aiTargets = [];
      aiFocusShipId = null;
      aiHitCells = [];
      document.getElementById('postGameRow')?.classList.add('hide');
      document.getElementById('placement').classList.add('hide');
      document.getElementById('boards').classList.add('hide');
      document.getElementById('status').classList.add('hide');
      document.getElementById('hud').classList.add('hide');
      document.getElementById('setup').classList.remove('hide');
      
    }

    function animate(cell, cls){
      const a=document.createElement('div'); a.className=`anim ${cls}`;
      cell.appendChild(a); setTimeout(()=>a.remove(),420);
    }

    let popupTimer = null;
    function showPopup(text, type='hit', ms=1200){
      const el = document.getElementById('popup');
      if(!el) return;
      if (fxLevel === 'low' && (type === 'hit' || type === 'sunk')) return;
      const scale = fxLevel === 'high' ? 1.2 : (fxLevel === 'low' ? 0.8 : 1);
      el.className = `popup ${type}`;
      el.textContent = text;
      void el.offsetWidth;
      el.classList.add('show');
      if(popupTimer) clearTimeout(popupTimer);
      popupTimer = setTimeout(()=> el.classList.remove('show'), Math.round(ms * scale));
    }

    function setStatus(t){ document.getElementById('status').textContent=t; }

    function updateHud(){
      const isP1Turn = currentPlayer===1;
      const shooter = isP1Turn ? state.p1 : (mode==='ai' ? state.ai : state.p2);
      const role = mode==='ai'
        ? (isP1Turn ? 'Kommandant' : 'KI')
        : (isP1Turn ? 'Spieler 1' : 'Spieler 2');
      const turn = phase==='placement' ? 'Platzierung' : (phase==='over' ? 'Ende' : (isP1Turn ? 'Dein Zug' : 'Gegnerzug'));
      const shots = shooter.totalShots || 0;
      const acc = shots ? Math.round(((shooter.hits||0) / shots) * 100) : 0;

      const byId = (id,val)=>{ const el=document.getElementById(id); if(el) el.textContent=val; };
      byId('hudRole', role);
      byId('hudTurn', turn);
      byId('hudShots', String(shots));
      byId('hudAcc', `${acc}%`);
    }

    function initSprites(){
      for(const s of SHIPS) sprites[s.id]=makeShipSprite(24, s.hue);
    }

    function makeShipSprite(sz=24,h=190){
      const cv=document.createElement('canvas'); cv.width=sz; cv.height=sz;
      const x=cv.getContext('2d');
      x.imageSmoothingEnabled=false;
      x.fillStyle='#0d1e2f'; x.fillRect(0,0,sz,sz);
      x.fillStyle=`hsl(${h} 70% 45%)`; x.fillRect(3,5,sz-6,sz-10);
      x.fillStyle=`hsl(${h} 80% 62%)`; x.fillRect(5,7,sz-10,4);
      x.fillStyle='rgba(255,255,255,.3)'; x.fillRect(7,12,4,4); x.fillRect(sz-11,12,4,4);
      x.fillStyle='#06101a'; x.fillRect(2,4,2,sz-8); x.fillRect(sz-4,4,2,sz-8);
      return cv.toDataURL('image/png');
    }

    function tone(at, freq, dur, type='sine', vol=0.08, glideTo=null){
      const o=actx.createOscillator(), g=actx.createGain();
      o.type=type;
      o.frequency.setValueAtTime(freq, at);
      if(glideTo) o.frequency.exponentialRampToValueAtTime(glideTo, at+dur);
      g.gain.setValueAtTime(.0001, at);
      g.gain.exponentialRampToValueAtTime(vol, at+.01);
      g.gain.exponentialRampToValueAtTime(.0001, at+dur);
      o.connect(g); g.connect(actx.destination);
      o.start(at); o.stop(at+dur+.02);
    }

    function noise(at, dur=.12, vol=.05, hp=200){
      const len = Math.max(1, Math.floor(actx.sampleRate * dur));
      const buf = actx.createBuffer(1, len, actx.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0;i<len;i++) data[i] = (Math.random()*2-1) * (1 - i/len);
      const src = actx.createBufferSource(); src.buffer = buf;
      const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value = hp;
      const g = actx.createGain();
      g.gain.setValueAtTime(vol, at);
      g.gain.exponentialRampToValueAtTime(.0001, at+dur);
      src.connect(f); f.connect(g); g.connect(actx.destination);
      src.start(at); src.stop(at+dur+.02);
    }

    function playSfx(type){
      try {
        ensureAudio();
        const now = actx.currentTime + 0.005;
        const master = fxLevel === 'low' ? 0.05 : (fxLevel === 'high' ? 0.14 : 0.09);

        if(soundStyle === 'arcade'){
          if(type==='hit'){ tone(now, 820,.05,'square',master); tone(now+.045,560,.07,'triangle',master*.85); }
          else if(type==='miss'){ tone(now, 220,.08,'sine',master*.7,130); }
          else if(type==='sunk'){ tone(now, 420,.06,'square',master); tone(now+.05,300,.08,'square',master); tone(now+.11,180,.14,'triangle',master*.8); }
          else if(type==='win'){ tone(now, 520,.08,'square',master); tone(now+.08,740,.08,'square',master); tone(now+.16,980,.12,'triangle',master); }
          else if(type==='lose'){ tone(now, 300,.1,'triangle',master*.8,190); tone(now+.09,190,.14,'sine',master*.7,120); }
          else if(type==='turn'){ tone(now, 680,.03,'sine',master*.6); }
          else if(type==='place'){ tone(now, 280,.03,'triangle',master*.5); }
          return;
        }

        // naval v2: tiefer + kurze Noise-Transienten
        if(type==='hit'){ noise(now,.08,master*.7,350); tone(now+.01,180,.1,'sawtooth',master*.8,120); }
        else if(type==='miss'){ noise(now,.12,master*.55,700); tone(now+.02,140,.14,'sine',master*.45,90); }
        else if(type==='sunk'){ noise(now,.16,master,250); tone(now+.01,160,.18,'sawtooth',master*.9,70); tone(now+.08,90,.22,'triangle',master*.7); }
        else if(type==='win'){ tone(now,220,.12,'triangle',master*.8); tone(now+.11,280,.13,'triangle',master*.85); tone(now+.24,360,.16,'sine',master); }
        else if(type==='lose'){ noise(now,.11,master*.5,400); tone(now+.01,170,.15,'triangle',master*.7,95); tone(now+.14,95,.2,'sine',master*.55); }
        else if(type==='turn'){ tone(now,300,.03,'sine',master*.5); }
        else if(type==='place'){ tone(now,200,.03,'sine',master*.45); }
      } catch(e){}
    }

    window.addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase()==='r'){ toggleOrientation(); }
    });

    initSprites();
    setMode('ai');
  </script>
</body>
</html>